;; Analyzed by ClojureScript 1.7.107
{:use-macros nil, :excludes #{}, :name ampere.middleware, :imports nil, :requires {freactive.core freactive.core, ampere.undo ampere.undo, ampere.utils ampere.utils, data clojure.data, clojure.data clojure.data}, :uses {groupEnd ampere.utils, log ampere.utils, group ampere.utils, warn ampere.utils, IReactive freactive.core, store-now! ampere.undo, error ampere.utils}, :defs {pure {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 10, :column 7, :end-line 10, :end-column 11, :arglists (quote ([handler])), :doc "Acts as an adaptor, allowing handlers to be writen as pure functions.\n  The ampere router passes the `app-db` atom as the first parameter to any handler.\n  This middleware adapts that atom to be the value within the atom.\n  If you strip away the error/efficiency checks, this middleware is doing:\n  `(reset! app-db (handler @app-db event-vec))`\n  You don't have to use this middleware directly. It is automatically applied to\n  your handler's middleware when you use `register-handler`.\n  In fact, the only way to by-pass automatic use of `pure` in your middleware\n  is to use the low level registration function `ampere.handlers/register-handler-base`"}, :name ampere.middleware/pure, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 11, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10, :end-line 10, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Acts as an adaptor, allowing handlers to be writen as pure functions.\n  The ampere router passes the `app-db` atom as the first parameter to any handler.\n  This middleware adapts that atom to be the value within the atom.\n  If you strip away the error/efficiency checks, this middleware is doing:\n  `(reset! app-db (handler @app-db event-vec))`\n  You don't have to use this middleware directly. It is automatically applied to\n  your handler's middleware when you use `register-handler`.\n  In fact, the only way to by-pass automatic use of `pure` in your middleware\n  is to use the low level registration function `ampere.handlers/register-handler-base`"}, log-ex {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 36, :column 7, :end-line 36, :end-column 13, :arglists (quote ([handler])), :doc "Middleware which catches and prints any handler-generated exceptions to console.\n  Handlers are called from within a core.async go-loop, and core.async produces\n  a special kind of hell when in comes to stacktraces. By the time an exception\n  has passed through a go-loop its stack is mangled beyond repair and you'll\n  have no idea where the exception was thrown.\n  So this middleware catches and prints to stacktrace before the core.async sausage\n  machine has done its work."}, :name ampere.middleware/log-ex, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 13, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 36, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Middleware which catches and prints any handler-generated exceptions to console.\n  Handlers are called from within a core.async go-loop, and core.async produces\n  a special kind of hell when in comes to stacktraces. By the time an exception\n  has passed through a go-loop its stack is mangled beyond repair and you'll\n  have no idea where the exception was thrown.\n  So this middleware catches and prints to stacktrace before the core.async sausage\n  machine has done its work."}, debug {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 54, :column 7, :end-line 54, :end-column 12, :arglists (quote ([handler])), :doc "Middleware which logs debug information to js/console for each event.\n  Includes a clojure.data/diff of the db, before vs after, showing the changes\n  caused by the event."}, :name ampere.middleware/debug, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 12, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 54, :end-line 54, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Middleware which logs debug information to js/console for each event.\n  Includes a clojure.data/diff of the db, before vs after, showing the changes\n  caused by the event."}, trim-v {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 70, :column 7, :end-line 70, :end-column 13, :arglists (quote ([handler])), :doc "Middleware which removes the first element of v, allowing you to write\n  more aesthetically pleasing handlers. No leading underscore on the event-v!\n  Your handlers will look like this:\n\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)\n  "}, :name ampere.middleware/trim-v, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 13, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 70, :end-line 70, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Middleware which removes the first element of v, allowing you to write\n  more aesthetically pleasing handlers. No leading underscore on the event-v!\n  Your handlers will look like this:\n\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)\n  "}, path {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 84, :column 7, :end-line 84, :end-column 11, :arglists (quote ([& args])), :doc "A middleware factory which supplies a sub-tree of `db` to the handler.\n  Works a bit like update-in. Supplies a narrowed data structure for the handler.\n  Afterwards, grafts the result of the handler back into db.\n  Usage:\n\n      (path :some :path)\n      (path [:some :path])\n      (path [:some :path] :to :here)\n      (path [:some :path] [:to] :here)\n  ", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name ampere.middleware/path, :variadic true, :file "target/client/ampere/middleware.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 84, :end-line 84, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "A middleware factory which supplies a sub-tree of `db` to the handler.\n  Works a bit like update-in. Supplies a narrowed data structure for the handler.\n  Afterwards, grafts the result of the handler back into db.\n  Usage:\n\n      (path :some :path)\n      (path [:some :path])\n      (path [:some :path] :to :here)\n      (path [:some :path] [:to] :here)\n  "}, undoable {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 107, :column 7, :end-line 107, :end-column 15, :arglists (quote ([explanation])), :doc "A Middleware factory which stores an undo checkpoint.\n  `explanation` can be either a string or a function. If it is a\n  function then must be:  (db event-vec) -> string.\n  `explanation` can be nil. in which case \"\" is recorded."}, :name ampere.middleware/undoable, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 15, :method-params ([explanation]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 107, :end-line 107, :max-fixed-arity 1, :fn-var true, :arglists (quote ([explanation])), :doc "A Middleware factory which stores an undo checkpoint.\n  `explanation` can be either a string or a function. If it is a\n  function then must be:  (db event-vec) -> string.\n  `explanation` can be nil. in which case \"\" is recorded."}, enrich {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 125, :column 7, :end-line 125, :end-column 13, :arglists (quote ([f])), :doc "Middleware factory which runs a given function `f` in the after position.\n  `f` is (db v) -> db\n  Unlike `after` which is about side effects, `enrich` expects f to process and alter\n  db in some useful way, contributing to the derived data, flowing vibe.\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them in a warning\n  down the bottom.\n  Almost any action (edit text, add new todo, remove a todo) requires a\n  complete reassesment of duplication errors and warnings. Eg: that edit\n  update might have introduced a new duplicate or removed one. Same with a\n  todo removal.\n  And to perform this enrichment, a function has to inspect all the todos,\n  possibly set flags on each, and set some overall list of duplicates.\n  And this duplication check might just be one check amoung many.\n  `f` would need to be both adding and removing the duplicate warnings.\n  By applying `f` in middleware, we keep the handlers simple and yet we\n  ensure this important step is not missed."}, :name ampere.middleware/enrich, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 13, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 125, :end-line 125, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Middleware factory which runs a given function `f` in the after position.\n  `f` is (db v) -> db\n  Unlike `after` which is about side effects, `enrich` expects f to process and alter\n  db in some useful way, contributing to the derived data, flowing vibe.\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them in a warning\n  down the bottom.\n  Almost any action (edit text, add new todo, remove a todo) requires a\n  complete reassesment of duplication errors and warnings. Eg: that edit\n  update might have introduced a new duplicate or removed one. Same with a\n  todo removal.\n  And to perform this enrichment, a function has to inspect all the todos,\n  possibly set flags on each, and set some overall list of duplicates.\n  And this duplication check might just be one check amoung many.\n  `f` would need to be both adding and removing the duplicate warnings.\n  By applying `f` in middleware, we keep the handlers simple and yet we\n  ensure this important step is not missed."}, after {:protocol-inline nil, :meta {:file "/Users/kyusa/GitHub/ampere/examples/todomvc/target/client/ampere/middleware.cljs", :line 150, :column 7, :end-line 150, :end-column 12, :arglists (quote ([f])), :doc "Middleware factory which runs a function `f` in the \"after handler\"\n  position presumably for side effects.\n  `f` is given the new value of `db`. It's return value is ignored.\n  Examples: `f` can run schema validation. Or write current state to localstorage. etc.\n  In effect, `f` is meant to sideeffect. It gets no chance to change db. See \"enrich\"\n  (if you need that.)"}, :name ampere.middleware/after, :variadic false, :file "target/client/ampere/middleware.cljs", :end-column 12, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 150, :end-line 150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Middleware factory which runs a function `f` in the \"after handler\"\n  position presumably for side effects.\n  `f` is given the new value of `db`. It's return value is ignored.\n  Examples: `f` can run schema validation. Or write current state to localstorage. etc.\n  In effect, `f` is meant to sideeffect. It gets no chance to change db. See \"enrich\"\n  (if you need that.)"}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc nil}